from __future__ import annotations

from pathlib import Path
from typing import Callable

from objects import Object


def beginning(script: str) -> str:
    return f"""\
# File generated by {script}.py
set pagination off
set print array on
set print pretty on
# pwd is core/src
set logging file ../tools/gdb_scripts/{script}.log
set logging on
"""


def run() -> str:
    return "run"


def indent_list(lines: list[str], num: int = 2) -> str:
    return "\n".join(indent(line, num) for line in lines)


def indent(text: str, num: int = 2) -> str:
    return num * " " + text if text else ""


def command_teardown(
    b_num: int, show_only_once: bool, continue_after_cmd: bool
) -> list[str]:
    delete_breakpoint = [
        "# deleting itself not to show multiple times",
        f"delete {b_num}",
    ]
    cont = [
        "# not stopping the debugger",
        "continue",
    ]

    buf = []
    if show_only_once:
        buf += delete_breakpoint
    if continue_after_cmd:
        buf += cont

    return buf


def breakpoint_and_command(obj: Object, cmd_num: int, command_content: str) -> str:
    return "\n".join(
        [
            f"# {obj.comment}",
            f"break {obj.breakpoint}",
            f"commands {cmd_num}",
            command_content,
            "end\n",
        ]
    )


def file_from_objects(
    file: Path,
    objects: list[Object],
    get_command_content: Callable[[Object, int], str],
    script: str,
) -> None:
    with open(file, "w") as f:
        f.write(beginning(script))
        f.write("\n")

        for index, obj in enumerate(objects, start=1):
            cmd_content = get_command_content(obj, index)
            f.write(breakpoint_and_command(obj, index, cmd_content))
            f.write("\n")

        f.write(run())
        f.write("\n")
